# 2. What is GitOps?

There are many ways of implementing GitOps, and we’ll look at several in this chapter, but at its core, GitOps is about applying the software development lifecycle to both application source code and infrastructure configuration—or infrastructure-as-Code. The Git repository becomes the source of truth for what is in production, what _was_ in production, and what _will_ be in production soon. In order to do so, the Git repository will have to include configuration files, application code, infrastructure definitions, and deployment manifests—everything needed to reproduce a fully working version of the application. 

Declarative representations are preferred over compiled artifacts, but when source code is compiled into artifacts, they need to be versioned and tied back to a commit within the Git repository itself. Tools like Terraform, Docker, and Kubernetes interpret these declarative files and automatically apply changes to the system to conform to the desired state.

Any changes to the Git repository are automatically and continuously applied to the target environment, no matter where the environment sits in the lifecycle—a development, staging, or production environment. This automated process ensures consistency and reduces the risk of manual errors. 

This can be achieved through a Push or a Pull Model, which we first saw in the previous chapter when looking at different CI / CD pipeline approaches for Kubernetes-based solutions. Due to Kubernetes’s influence within the GitOps space, it is often a foregone conclusion that the goal is to establish a Pull Model. However, a Pull Model is not required to implement GitOps. There are many ways to implement GitOps, and each approach has distinct trade-offs that should be evaluated in your specific context. 

Whether you use the Push Model or the Pull Model, one of the big advantages of using GitOps is that it provides transparency and visibility into the changes made to the system by keeping a log of all deployments and updates through the normal source control management process. The Git commit history is transformed into an audit trail that makes it easier to understand what changes were made when they occurred, and by whom. The combination of the complete configuration and code to produce an end-to-end working system and a versioned copy makes it relatively easy to roll back to a previous state in the event of issues. Of course, stateful portions of your systems will likely need additional engineering to ensure both new deployments and rollbacks are uneventful.

Using this approach can improve software delivery processes, resulting in greater efficiency, reliability, and scalability while simultaneously encouraging collaboration between development, operations, and other teams. This is the key reason why adopting this approach is critical to enabling a DevOps culture within an organization.

Due to the heavy reliance on Git—traditionally a software development tool—team members without an application development background can tend to struggle. Therefore, if you come from a non-developer background like a system administrator, network or security engineer, or other infrastructure discipline, it’s very important that you take the time to learn basic Git commands and a GitFlow process, as this knowledge will be critical for you to be effective on the team.

Terraform—and tools like it—are a critical component to a GitOps toolchain as the use of Infrastructure as Code is an important pillar of this approach, but it’s important to remember that Terraform is often just one ingredient in the grand recipe with the source control and pipelining tool playing the key role in facilitating the process. That’s why, in this book, we’ll be setting up sophisticated architectures using Terraform and CI / CD pipelines to provision them. Before we can get to that, we need to firmly understand what a CI / CD pipeline is and how to build one, which is what we will look at in the next section.