# 4. Limitations

The allure of an efficient code generation tool for infrastructure-as-code and Terraform is very real. However, it is not without its own limitations and common pitfalls that you should be aware of when venturing into this territory.

The biggest challenges with code generation tools for Terraform are not unique problems within the realm of Terraform and infrastructure-as-code but afflict the approach of reverse engineering or code generation in general. Code generated using reverse engineering tools often lacks the craftsmanship that handwritten code has engrained within it from day one. This can result in not only functional defects that need to be ferreted out but also countless occurrences of code quality and readability issues that need to be resolved before the codebase can really be used for its intended purposes: to maintain cloud environments via infrastructure-as-code.

One functional problem that often crops up in imported Terraform codebases is over-zealously defined explicit dependencies using the `depends_on` meta-argument. The `depends_on` clause is a valuable tool for resolving implicit dependencies between resources that Terraform can’t otherwise pick up automatically. But in most cases, an explicit definition of these dependencies between resources is unnecessary, adds additional bloat and complexity to the codebase, and can be detrimental to readability. 

Another example is that when the resource configuration is extracted from the cloud platform, its values are largely imported as hard-coded values that are scattered across all the resources declared. This creates an immediate backlog of technical debt to rationalize related constant values and extract a sane and then desirable set of input variables that can be used to define relevant configuration settings.

Lastly, there are often write-only attributes on Terraform resources that will not be returned by the cloud platform’s REST APIs because they contain sensitive or secret information. This is by design to protect from secret leakage and would not be a problem if the resource was provisioned originally from Terraform, as those sensitive values would be stored in the state. However, this creates a bit of a refactoring process because it means that in most cases, your Terraform codebase will not pass `terraform validate`, let alone a `terraform plan` without errors that need to be resolved.

Running plan immediately after you generate the code and import the resources can help you pick up subtle differences and irregularities in the import process. This can happen as the terraform code generation is far from 100% accurate.