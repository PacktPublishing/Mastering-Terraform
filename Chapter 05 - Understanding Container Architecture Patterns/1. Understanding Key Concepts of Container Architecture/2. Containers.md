# 2. Containers

Containers allow you to package your applications into an isolated environment logically separated from other applications without the overhead incurred by virtualizing the underlying physical hardware and the resource consumption of a full-on Operating System—whether it is Windows or Linux—the Operating System consumes resources that take away from your capacity.

Containers use two Linux kernel primitives: Namespaces and Control Groups. These constructs allow the Container Runtime to set up an isolated environment within the Linux Operating System. Namespaces are all about isolation, which allows us to split the Operating System into multiple virtual Operating Systems with its own process tree, root file system, user, etc. Each container might feel like a regular Operating System, but it's not. Control Groups police the allocation of the host systems resources—including CPU, memory, and Disk I/O—to ensure that the actual physical server is not overwhelmed by the resources consumed by the containers.

The last component that enables containers is a layered filesystem. This is similar to how we used to build Virtual Machine images—only with better isolation between layers. When we build a Virtual Machine layer, when we apply changes to and create a new Virtual Machine image, we can no longer sort out the base layer from the top layer. Containers can apply filesystem layers that contain only the differences between the lower layers. This approach creates an extremely compact and highly efficient way of layering changes onto each container image to compose the final file system that the container operates on—with the topmost layer being writable by the container itself.

One of the key benefits of containers is their efficiency. Unlike Virtual Machines, which require separate operating systems and resource allocations for each instance, containers directly leverage the host system's kernel. This approach means they consume fewer resources and start up much faster than their Virtual Machine counterparts. Multiple containers can run simultaneously on a single host, thus using system resources more efficiently. This allows us to create higher-density workloads—thus reducing the waste of valuable system resources like CPU and memory to idleness, and when working in the cloud, this waste is like pouring money down the drain!

