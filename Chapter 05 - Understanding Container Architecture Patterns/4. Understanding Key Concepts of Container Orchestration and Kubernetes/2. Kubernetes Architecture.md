# 2. Kubernetes Architecture

Kubernetes is a distributed software system, and its design is relatively similar to that of other such systems. Because its responsibility spans a cluster of interconnected computer systems that can scale from just a few to literally thousands, it is organized like an army. There are officers, soldiers, and a central command. The soldiers are organized into smaller sub-groups, and each needs to maintain continuous contact with the central command in order to operate effectively by receiving new orders and providing the status of the current situation. The central commands receive the status reports from the various officers that oversee their soldiers and operating orders and determine whether different areas of the battlefield need more troops or fewer troops, issuing orders to reallocate different sub-groups of the soldiers to different locations across the battlefield. Let's dive into each component and their roles.

## Master Node
The master node is the central command of the Kubernetes cluster—it’s essentially where the generals of the Army operate. For smaller skirmishes, there is typically only one central command, but for truly epic entanglement, you might need more than one for each theatre of war. It oversees the entire system and makes high-level decisions. Like any good Central Command, it must perform several functions.

- API Server: Any Army must take input from its civilian government, which provides the objectives to complete and defines what success looks like. In many ways, this is very much like the role of the API server. Instead of taking input from politicians via that red telephone, it takes input from the end user (usually a system administrator or software developer) over a REST-based interface. The definition of success looks a bit different as well, which is the definition of how the end user’s applications and services should be deployed and how to tell if they are healthy.
- Controller Manager: Napoleon Bonaparte famously said, “An army marches on its stomach,” which highlights the importance of sound logistics when waging war. An army is more than just boots and guns. You need food and water, uniforms and tens, and fuel for your trucks and trains. The controller manager performs a similar function as it is responsible for monitoring inventories and distributing resources so that the desired state of the Army is maintained and they are empowered to accomplish their mission.
- Scheduler: Our very own George Washington famously said “Discipline is the soul of an army”—and to enforce that discipline, an army must have an Officer Corps that efficiently executes orders across the field of battle assigning soldiers to across the battlefield to where they are most needed. In this sense, it assigns pods to appropriate nodes based on resource availability and the objective to be accomplished.
- “etcd”: Any army is made up of soldiers and organizational units, to keep track of all this complexity there must be a sophisticated Personnel Management office that keeps records of assignments, deployments, career progression, etc. They keep track of what everyone is doing and what they are doing in their military roles. “etcd” plays this role in Kubernetes by maintaining configuration data, the state of the cluster, and creating a single source of truth.

## Worker Nodes
Worker nodes are the battlefields where the soldiers of this army do what must be done to achieve the objective. They are the physical (or virtual) machines where your containers run. On any battlefield there must be a sergeant that commands his squad of soldiers. The sergeant of Kubernetes is called the Kubelet. Like a sergeant, the Kubelet is autonomous within its area of the battlefield, executing orders received from central command and commanding the troops within his squad—the pods and it maintains the chain of command. With its superiors at central command—or the master node—that might delegate new orders. 

The containers running within the node, being monitored by their attentive sergeant, the Kubelet, need a container runtime in order to operate. There are several different container runtimes, such as “containerd”, CRI-O, or Docker, which we learned about in the first section of this chapter. Although there are many container runtimes, we still use the same tooling—Docker—to build images. The runtime is really only responsible for running the containers. There are some other details to it, and it’s definitely a rabbit hole, but this is what we need to know within the context of this book.

With soldiers distributed across an expansive battlefield, there needs to be a way for messages to be sent back and forth between the soldiers, their officers, and the central command. On the battlefield, this has changed throughout history from flags, banners, smoke signals, drums, horns, and bugles to modern times with telegraph, radio, and satellite communication. For the pods, this is the network traffic that is being routed to the node. The kube-proxy, like the Kubelet, runs on every node and is responsible for routing network traffic to the correct destination.

## Pods

That’s enough about the big hats. It’s time to talk soldiers. A soldier is the smallest participant on the battlefield, and soldiers, collectively, are the primary force in military operations. The same is true for pods within the context of Kubernetes. Pods are where all the work actually happens. Everything else going on inside a Kubernetes cluster is to facilitate the effectiveness of the pods in achieving their individual objectives, much like the myriad of characters that support our frontline troopers on the battlefield by making sound strategic decisions, allocating resources, organizing soldiers into units, and assigning orders.

A pod is not a container but a Kubernetes-specific construct and, like the soldier, the smallest unit of deployment within a cluster. A pod can have one or more containers inside of it that share resources and configurations to perform a common objective.

Instead of directly deploying individual containers, you create a pod and place the containers within it. When you declare more than one container within the same Pod, you are tightly coupling them together—in that they share the same network namespace, IPC (Inter-Process Communication) namespace, and file system.

The diagram below illustrates these core components of Kubernetes architecture.
![Kubernetes Architecture][image-1]

_Key Kubernetes Architectural Components_

Now that we understand the core components of the architecture we'll delve into a couple other important topics. I do want to call out that this book is about mastering Terraform and while part of that journey is understanding the architectures that you will be designing and provisioning with Terraform this book does not intend to be an in-depth guide to Kubernetes. Hence, I am focusing on just the key concepts that you need to be aware of when building solutions with these technologies using Terraform.

## Services

For more complex military operations, we may need to allocate a larger military unit to complete the mission successfully. This is where we have a Lieutenant that would command multiple squads. The Lieutenant delegates orders to the appropriate squads, with each deployed to a different area on the battlefield. This is similar to the role of a Service in Kubernetes, which allows us to group pods together with a common purpose and distribute them across multiple nodes. The Service is responsible for load balancing across the pods, and any incoming requests intended for those pods would be addressed to the Service to route accordingly—much like how orders from a Captain or higher in the chain of command would be delegated down to a Lieutenant, and he would take the necessary steps to dole them out to the squads under his command.

In this way, the service plays a crucial role in workloads that require a stable endpoint for communicating with pods, such as a web application or a REST API. This is because Kubernetes assigns a stable IP address and DNS name to the service, which remains unchanged even if the underlying pods change, enabling other applications or services within or outside the cluster to establish a reliable connection with the service.

## Namespaces

Lastly, we need to cover an important concept of Kubernetes’ logical model: the namespace. The namespace provides complete separation from all the services and pods deployed within the cluster at the logical level. Namespaces do not apply to the physical resources of clusters, such as nodes or persistent volumes. They only apply within the logical realm of Kubernetes as it relates to Pods and other related resources. You can think of it as branches within the military. Resources in different namespaces, like soldiers in different branches of the army, share a central command, and they can communicate and coordinate with each other, but they are isolated in terms of chain of command and resource allocation. Therefore, pods in different namespaces can operate on the same nodes but can’t coexist in the same service since that, too, has a namespace.

We’ve covered the key components of Kubernetes architecture. There is definitely a lot more that is out of the scope of this book, but this should give you enough of the conceptual overhead to understand Kubernetes architecture at a high level. Next, we’ll delve a bit deeper into some of the resources that are used to configure Pods and Services.

[image-1]:	../images/Master-Worker-Relationship.png