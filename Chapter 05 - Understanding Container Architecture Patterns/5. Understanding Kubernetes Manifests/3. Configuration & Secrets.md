# 3. Configuration & Secrets

Because Kubernetes is where we will host our applications and services we need to have a way to provide runtime configuration settings both non-sensitive and secret.

## ConfigMaps

As we discussed in the previous section, a ConfigMap is how we pass non-sensitive data into our Pods. The ConfigMap is a key area where Terraform and Kubernetes integration takes place because many of the configuration settings are likely generated by Terraform. This is an important consideration when designing how you provision to Kubernetes, as you want to minimize the manual steps required to provision to Kubernetes. We’ll look at strategies on how to avoid this in future sections covering the Kubernetes and Helm providers.

	apiVersion: v1
	kind: ConfigMap
	metadata:
	  name: my-config
	data:
	  my-value: "Hello, Kubernetes!"

This ConfigMap is named `my-config`, and it holds a key-value pair of `my-value: Hello, Kubernetes!`.

Now, when we want to reference this ConfigMap from one of our deployments, we simply use the `configMapRef` block to pull in the correct value from the ConfigMap and set an Environment Variable inside our container.

	apiVersion: apps/v1
	kind: Deployment
	metadata:
	  name: my-app
	spec:
	  replicas: 1
	  selector:
	    matchLabels:
	      app: my-app
	  template:
	    metadata:
	      labels:
	        app: my-app
	    spec:
	      containers:
	      - name: my-app
	        image: my-app:1.0
	        env:
	        - name: MY_VALUE
	          valueFrom:
	            configMapKeyRef:
	              name: my-config
	              key: my-value

In this deployment, the application `my-app` has an environment variable `MY_VALUE` whose value is pulled from the ConfigMap `my-config` and when the pod is running it can get the value `Hello, Kubernetes!` from that environment variable.

## Secrets

Just like the non-sensitive configuration settings, many of our secrets will be provisioned by Terraform using the target cloud platform’s secret management service. As a result, we won’t be using the Kubernetes Secret resource but will be defining a SecretProviderClass that will enable integration with the cloud platform’s secret management service and pull in the desired secrets. Because this is cloud platform specific, we’ll cover this in more detail in each of the solutions we build on AWS, Azure, and Google Cloud using their respective managed Kubernetes offerings.
