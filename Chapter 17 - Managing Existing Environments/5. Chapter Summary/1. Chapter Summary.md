# 1. Chapter Summary

In this chapter, we looked at how to manage existing environments using Terraform. At the start, we embarked on a comprehensive exploration of the various operating models that teams with differing roles and responsibilities employ within organizations of varying sizes and how they integrate Terraform into their day-to-day—from a simple standalone application to navigating the complexities of shared infrastructure services like a centralized network to all the nuances of building shared services that intertwine across the enterprise and face both the challenges of interdependencies experienced with shared infrastructure coupled with their own application development release processes.

A significant portion of this chapter was dedicated to simply applying changes to our existing environments. This included the seemingly mundane process of upgrading our Terraform tools—ranging from the Terraform executable itself to the Terraform providers we use and the modules we consume within our solutions. We also discussed the refactoring that may be necessary with our own code and addressed how to handle unplanned changes—like when disaster strikes. This discussion was akin to preparing for a storm; just as one would secure their windows and doors, we explored how to use Terraform to prepare our environments for when we needed to take action during an outage.

We concluded the chapter by discussing the more common break-fixing scenarios that you will encounter in your day-to-day operations of managing existing environments with Terraform. 

In the next, chapter we’ll be looking to close out the book by discussing some important things to consider as you take your next steps in mastering Terraform.