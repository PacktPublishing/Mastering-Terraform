# 1. Chapter Summary

In this chapter, we looked in-depth at the utility providers that HashiCorp has built to help us augment our Infrastructure-as-Code solutions. We learned how to integrate with external systems, work with assets stored on the filesystem, and randomize and fill in whitespace within Terraform. These providers are incredibly versatile, and as you explore them more, you will find them more and more valuable.

Like other providers, always reference the provider in your `required_providers` block with an explicit version number. Do not implicitly take the latest. Other than that, resources from these providers can be embedded in any Terraform module—take special care when designing reusable modules to ensure you have minimal provider requirements on upstream client modules, as this can add additional complexity to users who hope to reuse your module that requires a dozen different providers to be declared!

In the next chapter, we will establish some architectural concepts we can apply to our Infrastructure-as-Code, no matter the cloud platform we target. After all, our Infrastructure-as-Code is only as good as the architecture that it defines. Therefore, we must have a sound understanding of typical elements of cloud service anatomy and the mechanics of different computational paradigms such as Virtual Machines and Containers. So next, we’ll look at Virtual Machine architecture through a multi-cloud lens.